* Interface tweaks 
** general setting
   Let line wrap in org-mode
   #+begin_src emacs-lisp
     (use-package adaptive-wrap
       :ensure t
       :config
       (progn
	 (add-hook 'visual-line-mode-hook #'adaptive-wrap-prefix-mode)
	 (global-visual-line-mode t)))


   #+end_src

   #+RESULTS:
   : t

** key-bindings
   #+BEGIN_SRC emacs-lisp
     ;; use cmd + n and cmd + p to select next and previous lines
     (global-set-key (kbd "s-n") (kbd "C-S-n"))
     (global-set-key (kbd "s-p") (kbd "C-S-p"))

     ;; use cmd + / to comment region of code
     (global-set-key (kbd "s-/") 'comment-region)
     ;; use cmd + \ to uncomment region of code
     (global-set-key (kbd "s-\\") 'uncomment-region)

     ;; use c-c c-c to execute a function in scheme
     (global-set-key (kbd "C-c C-c") 'eval-last-sexp)

     ;; use f4 to format whole buffer
     (global-set-key (kbd "<f10>") (kbd "C-x h C-M-\\"))
     ;; use f3 to use org-edit-special
     (global-set-key (kbd "<f3>") (kbd "C-c '"))
     ;; use f5 to revert the buffer
     (global-set-key (kbd "<f5>") 'revert-buffer)
     ;; use f6 to toggle the display of inline image
     (global-set-key (kbd "<f6>") (kbd "C-c C-x C-v"))


   #+END_SRC

   #+RESULTS:
   : revert-buffer

   #+BEGIN_SRC emacs-lisp
     (setq org-src-tab-acts-natively t)
     (tool-bar-mode -1)

     ;; use y/n for yes/no
     (fset 'yes-or-no-p 'y-or-n-p)

     ;; Show matching arenthesis
     (show-paren-mode 1)
     (setq show-paren-delay 0)

     (require 'paren)
     (set-face-background 'show-paren-match (face-background 'default))
     (set-face-foreground 'show-paren-match "#def")
     (set-face-attribute 'show-paren-match nil :weight 'extra-bold)

     ;; no need for prompt for confirm when execute code block in org-mode
     (setq org-confirm-babel-evaluate nil)

     ;; make sure environment variables inside Emacs look the same as in the user's shell
     (use-package exec-path-from-shell
       :ensure t
       :config
       (progn
	 (when (memq window-system '(mac ns x))
	   (exec-path-from-shell-initialize))))
   #+END_SRC
** make tag align to the right margin
   #+BEGIN_SRC emacs-lisp
     (add-hook 'org-finalize-agenda-hook 'place-agenda-tags)
     (defun place-agenda-tags ()
       "Put the agenda tags by the right border of the agenda window."
       (setq org-agenda-tags-column (- 4 (window-width)))
       (org-agenda-align-tags))

   #+END_SRC
   #+RESULTS:
   : place-agenda-tags

** use indent-guide
   #+BEGIN_SRC emacs-lisp
     (use-package indent-guide
       :ensure t
       :config
       (indent-guide-global-mode))
   #+END_SRC

   #+RESULTS:
   : t
* Themes
  #+BEGIN_SRC emacs-lisp
    (use-package spacemacs-common
      :ensure spacemacs-theme
      :config
      (progn
	(load-theme 'spacemacs-dark t)
	;;    (add-hook 'after-init-hook (lambda () (load-theme 'spacemacs-dark)))
	))
  #+END_SRC

  #+RESULTS:
  : t

* try
  #+BEGIN_SRC emacs-lisp
    (use-package try
      :ensure t)
  #+END_SRC

  #+RESULTS:

* which-key
  #+BEGIN_SRC emacs-lisp
    (use-package which-key
      :ensure t
      :config (which-key-mode))
  #+END_SRC

  #+RESULTS:
  : t

* Company
  #+BEGIN_SRC emacs-lisp
    (use-package company
      :ensure t
      :config
      (add-hook 'after-init-hook 'global-company-mode t)
      (setq company-minimum-prefix-length 3)
      (setq company-idle-delay 0))
  #+END_SRC

  Set the manner how tab complete
  #+BEGIN_SRC emacs-lisp
    ;; bind company-select-next to tab
    (eval-after-load 'company
      '(progn
	 (define-key company-active-map (kbd "TAB") 'company-complete-common-or-cycle)
	 (define-key company-active-map [tab] 'company-complete-common-or-cycle)))


  #+END_SRC
  #+RESULTS:
  : company-complete-common-or-cycle

** Set use TAB key to do company complete, see [[https://www.emacswiki.org/emacs/CompanyMode][Company interferes with Yasnippetâ€™s native behaviour]].
   #+BEGIN_SRC emacs-lisp
     ;; (defun check-expansion ()
     ;;   (save-excursion
     ;;     (if (looking-at "\\_>") t
     ;;       (backward-char 1)
     ;;       (if (looking-at "\\.") t
     ;;         (backward-char 1)
     ;;         (if (looking-at "->") t nil)))))

     ;; (defun do-yas-expand ()
     ;;   (let ((yas/fallback-behavior 'return-nil))
     ;;     (yas/expand)))

     ;; (defun tab-indent-or-complete ()
     ;;   (interactive)
     ;;   (if (minibufferp)
     ;;       (minibuffer-complete)
     ;;     (if (or (not yas/minor-mode)
     ;;             (null (do-yas-expand)))
     ;;         (if (check-expansion)
     ;;             (company-complete-common)
     ;;           (indent-for-tab-command)))))

     ;; (global-set-key [tab] 'tab-indent-or-complete)

   #+END_SRC
   #+RESULTS:
   : tab-indent-or-complete

* Autocomplete
  #+BEGIN_SRC emacs-lisp
    (use-package auto-complete 
      :ensure t
      :init
      :config
      (progn
	(ac-config-default))
      )
  #+END_SRC 

  #+RESULTS:
  : t
* Yasnippet
  #+BEGIN_SRC emacs-lisp
    (use-package yasnippet
      :ensure t
      :init
      (yas-global-mode 1))

    (use-package yasnippet-snippets
      :ensure t)
  #+END_SRC

  #+RESULTS:

* Org-mode enhance
  # ** org-bullets
  #    #+BEGIN_SRC emacs-lisp
  #      (use-package org
  #        :ensure t)
  #      (use-package org-ac
  #        :ensure t
  #        :config
  #        (org-ac/config-default))
  #      (use-package org-bullets
  #        :ensure t
  #        :config
  #        (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

  #      (custom-set-variables
  #       '(org-directory "~/OneDrive/notes"))
  #      (global-set-key "\C-ca" 'org-agenda)
  #    #+END_SRC
** make code-block could be executed in org-mode
   #+BEGIN_SRC emacs-lisp
     (org-babel-do-load-languages
      'org-babel-load-languages
      '(
	(lisp . t)
	(shell . t)
	;;   (powershell . t)
	;;   (R . t)
	(C . t)
	(plantuml . t)))
     ;;(add-hook 'org-mode-hook (lambda () (org-indent-mode t)))
   #+END_SRC

   #+RESULTS:

** highlight within code block in emacs org-mode
   #+BEGIN_SRC emacs-lisp
     (setq org-src-fontify-natively t)
   #+END_SRC
** remove numbering from headers when exporting from org-mode
   #+BEGIN_SRC emacs-lisp
     ;; (setq org-export-with-section-numbers nil)
   #+END_SRC

   #+RESULTS:

   ** htmlize, which makes exported html file with highlight
   #+BEGIN_SRC emacs-lisp
     (use-package htmlize
       :ensure t)
   #+END_SRC
   #+RESULTS:
   : t

   # ** For org-capture
   #    By default, running org-capture brings up a form to capture a "task" but things get really cool when you start making your own capture templates. With capture templates, you can speed up recording information and then tell org-mode to store it where you want it.
   #    #+BEGIN_SRC emacs-lisp
   #      (global-set-key (kbd "C-c c")
   # 		     'org-capture)

   #      (setq org-capture-templates
   # 	   '(("a" "Appointment" entry (file  "~/OneDrive/notes/orgfiles/appointments.org" "Appointments")
   # 	      "* TODO %?\n:PROPERTIES:\n\n:END:\nDEADLINE: %^T \n %i\n")
   # 	     ("n" "Note" entry (file+headline "~/OneDrive/notes/orgfiles/notes.org" "Notes")
   # 	      "* Note %?\n%T")
   # 	     ("l" "Link" entry (file+headline "~/OneDrive/notes/orgfiles/links.org" "Links")
   # 	      "* %? %^L %^g \n%T" :prepend t)
   # 	     ("b" "Blog idea" entry (file+headline "~/OneDrive/notes/orgfiles/blog_ideas.org" "Blog Topics:")
   # 	      "* %?\n%T" :prepend t)
   # 	     ("t" "To Do Item" entry (file+headline "~/OneDrive/notes/orgfiles/to_do_items.org" "To Do Items")
   # 	      "* %?\n%T" :prepend t)
   # 	     ("j" "Journal" entry (file+datetree "~/OneDrive/notes/journal.org")
   # 	      "* %?\nEntered on %U\n  %i\n  %a")
   # 	     ("r" "Reading" entry (file "~/OneDrive/notes/orgfiles/reading-notes.org")
   # 	      "* %?\n%i\n")))

   #    #+END_SRC

   #    #+RESULTS:
   #    | a | Appointment | entry | (file ~/OneDrive/notes/orgfiles/appointments.org Appointments)        | * TODO %?\n:PROPERTIES:\n\n:END:\nDEADLINE: %^T \n %i\n |          |   |
   #    | n | Note        | entry | (file+headline ~/OneDrive/notes/orgfiles/notes.org Notes)             | * Note %?\n%T                                           |          |   |
   #    | l | Link        | entry | (file+headline ~/OneDrive/notes/orgfiles/links.org Links)             | * %? %^L %^g \n%T                                       | :prepend | t |
   #    | b | Blog idea   | entry | (file+headline ~/OneDrive/notes/orgfiles/blog_ideas.org Blog Topics:) | * %?\n%T                                                | :prepend | t |
   #    | t | To Do Item  | entry | (file+headline ~/OneDrive/notes/orgfiles/to_do_items.org To Do Items) | * %?\n%T                                                | :prepend | t |
   #    | j | Journal     | entry | (file+datetree ~/OneDrive/notes/journal.org)                          | * %?\nEntered on %U\n  %i\n  %a                         |          |   |
   #    | r | Reading     | entry | (file ~/OneDrive/notes/orgfiles/reading-notes.org)                    | * %?\n%i\n                                              |          |   |
   # ** [[https://stackoverflow.com/questions/17435995/paste-an-image-on-clipboard-to-emacs-org-mode-file-without-saving-it][paste an image on clipboard to emacs org mode file without saving it]]
   #    #+BEGIN_SRC emacs-lisp
   #      (defun my-org-screenshot ()
   #        (interactive)
   #        (org-display-inline-images)
   #        (setq filename
   # 	     (concat
   # 	      (make-temp-name
   # 	       (concat (file-name-nondirectory (buffer-file-name))
   # 		       "_imgs/"
   # 		       (format-time-string "%Y%m%d_%H%M%S_")) ) ".png"))
   #        (unless (file-exists-p (file-name-directory filename))
   # 	 (make-directory (file-name-directory filename)))
   #        ;; take screenshot
   #        (if (eq system-type 'darwin)
   # 	   (call-process "screencapture" nil nil nil "-i" filename))
   #        (if (eq system-type 'gnu/linux)
   # 	   (call-process "import" nil nil nil filename))
   #        ;; insert into file if correctly taken
   #        (if (file-exists-p filename)
   # 	   (insert (concat "[[file:" filename "]]"))))
   #    #+END_SRC

   #    #+RESULTS:
   #    : my-org-screenshot

* tab-bar
  #+BEGIN_SRC emacs-lisp
    ;; add tab-bar on top of window to show different buffer
    (use-package tabbar
      :ensure t
      :config
      (setq tabbar-mode 1))
  #+END_SRC  

  #+RESULTS:
  : t

* ace-windwo
  #+BEGIN_SRC emacs-lisp
    (use-package ace-window
      :ensure t
      :init
      :config
      (progn
	(setq aw-scope 'frame)
	(global-set-key (kbd "C-x O") 'other-frame)
	(global-set-key [remap other-window] 'ace-window)
	(custom-set-faces
	 '(aw-leading-char-face
	   ((t (:inherit ace-jump-face-foreground :height 3.0))))) 
	))
  #+END_SRC

  #+RESULTS:
  : t

* Swiper / Ivy / Counsel
  Swiper gives us a really efficient incremental search with regular expressions and Ivy / Counsel replace a lot of ido or helms completion functionality
  #+BEGIN_SRC emacs-lisp
    ;; it looks like counsel is a requirement for swiper
    (use-package counsel
      :ensure t
      :bind
      (("M-y" . counsel-yank-pop)
       :map ivy-minibuffer-map
       ("M-y" . ivy-next-line)))

    (use-package ivy
      :ensure t
      :diminish (ivy-mode)
      :bind (("C-x b" . ivy-switch-buffer))
      :config
      (ivy-mode 1)
      (setq ivy-use-virtual-buffers t)
      (setq ivy-count-format "%d/%d ")
      (setq ivy-display-style 'fancy))


    (use-package swiper
      :ensure try
      :bind (("C-s" . swiper)
	     ("C-r" . swiper)
	     ("C-c C-r" . ivy-resume)
	     ("M-x" . counsel-M-x)
	     ("C-x C-f" . counsel-find-file))
      :config
      (progn
	(ivy-mode 1)
	(setq ivy-use-virtual-buffers t)
	(setq ivy-display-style 'fancy)
	(define-key read-expression-map (kbd "C-r") 'counsel-expression-history)
	))
  #+END_SRC

  #+RESULTS:
  : counsel-find-file

* Lisp Programming Configuration
** eldoc to show the argument list of the function call you are currently writing in the echo area
   #+BEGIN_SRC emacs-lisp
     (use-package eldoc
       :ensure t
       :init
       :config
       (progn
	 (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
	 (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
	 (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)
	 ;; highlight eldoc arguments in emacslisp
	 (defun eldoc-get-arg-index ()
	   (save-excursion
	     (let ((fn (eldoc-fnsym-in-current-sexp))
		   (i 0))
	       (unless (memq (char-syntax (char-before)) '(32 39)) ; ? , ?'
		 (condition-case err
		     (backward-sexp)             ;for safety
		   (error 1)))
	       (condition-case err
		   (while (not (equal fn (eldoc-current-symbol)))
		     (setq i (1+ i))
		     (backward-sexp))
		 (error 1))
	       (max 0 i))))

	 (defun eldoc-highlight-nth-arg (doc n)
	   (cond ((null doc) "")
		 ((<= n 0) doc)
		 (t
		  (let ((i 0))
		    (mapconcat
		     (lambda (arg)
		       (if (member arg '("&optional" "&rest"))
			   arg
			 (prog2
			     (if (= i n)
				 (put-text-property 0 (length arg) 'face 'underline arg))
			     arg
			   (setq i (1+ i)))))
		     (split-string doc) " ")))))

	 (defadvice eldoc-get-fnsym-args-string (around highlight activate)
	   ""
	   (setq ad-return-value (eldoc-highlight-nth-arg ad-do-it
							  (eldoc-get-arg-index))))
	 ))
   #+END_SRC

   #+RESULTS:
   : t

** paredit which keeps parentheses balanced
   #+BEGIN_SRC emacs-lisp
     (use-package paredit
       :ensure t
       :init
       :config
       (progn
	 (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)
	 (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
	 (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
	 (add-hook 'ielm-mode-hook             #'enable-paredit-mode)
	 (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
	 (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
	 (add-hook 'scheme-mode-hook           #'enable-paredit-mode)
	 (add-hook 'racket-mode-hook           #'enable-paredit-mode)
	 (add-hook 'common-lisp-mode-hook      #'enable-paredit-mode)

	 ;;set { and } 
	 ;; (define-key js-mode-map "{" 'paredit-open-curly)
	 ;; (define-key js-mode-map "}" 'paredit-close-curly-and-newline)

	 ;; paredit with eldoc
	 (require 'eldoc) ; if not already loaded
	 (eldoc-add-command
	  'paredit-backward-delete
	  'paredit-close-round)

	 ;; paredit with slime repl
	 (add-hook 'slime-repl-mode-hook (lambda () (paredit-mode +1)))
	 ;; To alleviate the annoying habit of grabbing DEL in slime's REPL
	 ;; Stop SLIME's REPL from grabbing DEL,
	 ;; which is annoying when backspacing over a '('
	 (defun override-slime-repl-bindings-with-paredit ()
	   (define-key slime-repl-mode-map
	     (read-kbd-macro paredit-backward-delete-key) nil))
	 (add-hook 'slime-repl-mode-hook 'override-slime-repl-bindings-with-paredit)

	 ;; paredit with electric return
	 (defvar electrify-return-match
	   "[\]}\)\"]"
	   "If this regexp matches the text after the cursor, do an \"electric\"
       return.")
	 (defun electrify-return-if-match (arg)
	   "If the text after the cursor matches `electrify-return-match' then
       open and indent an empty line between the cursor and the text.  Move the
       cursor to the new line."
	   (interactive "P")
	   (let ((case-fold-search nil))
	     (if (looking-at electrify-return-match)
		 (save-excursion (newline-and-indent)))
	     (newline arg)
	     (indent-according-to-mode)))
	 ;; Using local-set-key in a mode-hook is a better idea.
	 (global-set-key (kbd "RET") 'electrify-return-if-match)))
   #+END_SRC

   #+RESULTS:
   : t

** Programming with common-lisp 
*** Slime for common-lisp
    #+BEGIN_SRC emacs-lisp
      ;; lisp-mode could works with common-lisp, so there is no need to invoke
      ;; common-lisp-mode directly
      (use-package lisp-mode
	:config
	(use-package elisp-slime-nav
	  :ensure t
	  :commands elisp-slime-nav-mode)
	(use-package macrostep
	  :ensure t
	  :bind ("C-c e" . macrostep-expand))

	(use-package slime
	  :ensure t
	  :commands (slime slime-lisp-mode-hook)
	  :config
	  (progn
	    (add-to-list 'slime-contribs 'slime-fancy)
	    (slime-setup)
	    (use-package slime-company
	      :ensure t
	      :config
	      (progn
		(slime-setup '(slime-fancy slime-company)))))))

    #+END_SRC
    #+RESULTS:
    : t
** set variables about lisp-mode to work with emacslisp
   #+BEGIN_SRC emacs-lisp
     (add-hook 'emacs-lisp-mode-hook #'turn-on-eldoc-mode)
     (add-hook 'emacs-lisp-mode-hook #'elisp-slime-nav-mode)
     (add-hook 'ielm-mode-hook #'elisp-slime-nav-mode)
     (add-hook 'ielm-mode-hook #'turn-on-eldoc-mode)
     (add-hook 'lisp-interaction-mode-hook #'turn-on-eldoc-mode)
     (add-hook 'lisp-mode-hook #'slime-lisp-mode-hook)

     (setq inferior-lisp-program "sbcl.exe --dynamic-space-size 1024")
   #+END_SRC

   #+RESULTS:
   : sbcl.exe --dynamic-space-size 1024

** Programming with Racket
   #+BEGIN_SRC emacs-lisp
     (use-package racket-mode
       :ensure t
       :init
       :config
       (progn
	 (setq racket-program "c:/Program Files/Racket/Racket.exe")
	 (add-hook 'racket-mode-hook
		   (lambda ()
		     (define-key racket-mode-map (kbd "C-c r") 'racket-run)))
	 (setq tab-always-indent 'complete)
	 (add-hook 'racket-mode-hook      #'racket-unicode-input-method-enable)
	 (add-hook 'racket-repl-mode-hook #'racket-unicode-input-method-enable)

	 ;; setup file ending in ".scheme" to open in racket-mode 
	 (add-to-list 'auto-mode-alist '("\\.scheme\\'" . racket-mode))
	 ))
   #+END_SRC

   #+RESULTS:
   : t

* hook with different modes
** paredit, eldoc, show-paren and electric return
   #+BEGIN_SRC emacs-lisp
     (add-hook 'emacs-lisp-mode-hook
	       (lambda ()
		 (paredit-mode t)
		 (turn-on-eldoc-mode)
		 (eldoc-add-command
		  'paredit-backward-delete
		  'paredit-close-round)
		 (local-set-key (kbd "RET") 'electrify-return-if-match)
		 (eldoc-add-command 'electrify-return-if-match)
		 (show-paren-mode t)))
   #+END_SRC

   #+RESULTS:
   | (lambda nil (paredit-mode t) (turn-on-eldoc-mode) (eldoc-add-command (quote paredit-backward-delete) (quote paredit-close-round)) (local-set-key (kbd RET) (quote electrify-return-if-match)) (eldoc-add-command (quote electrify-return-if-match)) (show-paren-mode t)) | elisp-slime-nav-mode | enable-paredit-mode | turn-on-eldoc-mode | ac-emacs-lisp-mode-setup |

* Set variables
** set ingore case during completion
   #+BEGIN_SRC emacs-lisp
     (setq company-etags-ignore-case t)
     (setq company-dabbrev-code-ignore-case t)
     (setq company-dabbrev-ignore-case t)
     (setq company-emacs-eclim-ignore-case t)
     (setq company-irony-ignore-case t)
     (setq completion-ignore-case t)
   #+END_SRC

   #+RESULTS:
   : t
** for downscaling inline iamges in org-mode
   #+BEGIN_SRC emacs-lisp
     (setq org-image-actual-width nil)
   #+END_SRC

   #+RESULTS:

* R
  - Install ESS
  #+BEGIN_SRC emacs-lisp
    (use-package ess
      :ensure t
      :init
      ;;  :init (require 'ess-site)
      :config
      (progn
	(setq comint-input-ring-size 1000)
	(setq ess-indent-level 4)
	(setq ess-arg-function-offset 4)
	(setq ess-else-offset 4)
	(add-hook 'inferior-ess-mode-hook
		  '(lambda nil
		     (define-key inferior-ess-mode-map [\C-up]
		       'comint-previous-matching-input-from-input)
		     (define-key inferior-ess-mode-map [\C-down]
		       'comint-next-matching-input-from-input)
		     (define-key inferior-ess-mode-map [\C-x \t]
		       'comint-dynamic-complete-filename)
		     (setenv "LANG" "en_US.UTF-8")
		     )
		  )
	(add-hook 'ess-mode-hook 
		  (lambda () 
		    (setq truncate-lines t)
		    (auto-fill-mode)))

	))
  #+END_SRC

  #+RESULTS:
  : t

* Treemacs
  #+BEGIN_SRC emacs-lisp
    (use-package treemacs
      :ensure t
      :defer t
      :init
      (with-eval-after-load 'winum
	(define-key winum-keymap (kbd "M-0") #'treemacs-select-window))
      :config
      (progn
	(setq treemacs-collapse-dirs              (if (executable-find "python") 3 0)
	      treemacs-file-event-delay           5000
	      treemacs-follow-after-init          t
	      treemacs-follow-recenter-distance   0.1
	      treemacs-goto-tag-strategy          'refetch-index
	      treemacs-indentation                2
	      treemacs-indentation-string         " "
	      treemacs-is-never-other-window      nil
	      treemacs-no-png-images              nil
	      treemacs-project-follow-cleanup     nil
	      treemacs-recenter-after-file-follow nil
	      treemacs-recenter-after-tag-follow  nil
	      treemacs-show-hidden-files          t
	      treemacs-silent-filewatch           nil
	      treemacs-silent-refresh             nil
	      treemacs-sorting                    'alphabetic-desc
	      treemacs-tag-follow-cleanup         t
	      treemacs-tag-follow-delay           1.5
	      treemacs-width                      40)

	(treemacs-follow-mode t)
	(treemacs-filewatch-mode t)
	(pcase (cons (not (null (executable-find "git")))
		     (not (null (executable-find "python3"))))
	  (`(t . t)
	   (treemacs-git-mode 'extended))
	  (`(t . _)
	   (treemacs-git-mode 'simple))))
      :bind
      (:map global-map
	    ("M-0"       . treemacs-select-window)
	    ("C-x t 1"   . treemacs-delete-other-windows)
	    ("C-x t t"   . treemacs)
	    ("C-x t B"   . treemacs-bookmark)
	    ("C-x t C-t" . treemacs-find-file)
	    ("C-x t M-t" . treemacs-find-tag)))

    (use-package treemacs-evil
      :after treemacs evil
      :ensure t)

    (use-package treemacs-projectile
      :after treemacs projectile
      :ensure t)
  #+END_SRC

  #+RESULTS:~
* Docker 
** dockerfile-mode
   #+begin_src emacs-lisp
     (use-package dockerfile-mode
       :ensure t
       :init 
       :config
       (progn
	 (add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-mode))
	 ))
   #+end_src 

   #+RESULTS:
   : t
* Powershell within emacs
  - Enable powershell mode within emacs, after installation just run: M-x powershell to enter that mode
  #+begin_src emacs-lisp
    (use-package powershell
      :ensure t
      :init
      )
  #+end_src
  
  # - Execute two command in powershell to set the window size to avoid warning 
  #   #+begin_src powershell
  #     $height = (Get-Host).UI.RawUI.MaxWindowSize.Height
  #     $width = (Get-Host).UI.RawUI.MaxWindowSize.Width

  #     # or 
  #     # (Get-Host).UI.RawUI.MaxWindowSize
  #   #+end_src 

  # * Configuration for outline
  #   #+begin_src emacs-lisp
  #     ; first call 'clone-indirect-buffer'. Then...
  #     ; This function works between buffer and it's clone.
  #     (defun my/goto-same-spot-in-other-buffer () 
  #       "Go to the same location in the other buffer. Useful for when you have cloned indirect buffers"
  #       (interactive)
  #       (let ((my/goto-current-point (point)))
  # 	(other-window 1)
  # 	(goto-char my/goto-current-point)
  # 	(when (invisible-p (point))
  # 	  (org-reveal)))
  #       )

  #     ; This function is a clone-to-buffer jump only:
  #     ; It does find the other buffer first thou instead of just jumping to the other 
  #     ; window as does the function above.
  #     (defun my/jump-to-point-and-show ()
  #       "Switch to a cloned buffer's base buffer and move point to the
  #     cursor position in the clone."
  #       (interactive)
  #       (let ((buf (buffer-base-buffer)))
  # 	(unless buf
  # 	  (error "You need to be in a cloned buffer!"))
  # 	(let ((pos (point))
  # 	      (win (car (get-buffer-window-list buf))))
  # 	  (if win
  # 	      (select-window win)
  # 	    (other-window 1)
  # 	    (switch-to-buffer buf))
  # 	  (goto-char pos)
  # 	  (when (invisible-p (point))
  # 	    (show-branches)))))

  #     (global-set-key (kbd "<s-mouse-1>") 'my/goto-same-spot-in-other-buffer)
  #     (global-set-key (kbd "s-m") 'my/goto-same-spot-in-other-buffer)
  #     (global-set-key (kbd "<C-s-mouse-1>") 'my/jump-to-point-and-show)
  #     (global-set-key (kbd "C-s-m") 'my/jump-to-point-and-show)
  #   #+end_src 

  #   #+RESULTS:

* Javascript
** js2-mode 
   #+begin_src emacs-lisp
     (use-package ac-js2
       :ensure t
       :init
       :config 
       (progn
	 (use-package js2-mode
	   :ensure t
	   :init)
	 (add-hook 'js-mode-hook 'js2-minor-mode)
	 (add-hook 'js2-mode-hook 'ac-js2-mode)
	 (add-hook 'js2-mode-hook (lambda ()
				    (setq paredit-mode t)
				    ))
	 )
       )
   #+end_src 

   #+RESULTS:
   : t
   # ** using paredit with non lisp mode 
   #    #+begin_src emacs-lisp
   #      (require 'paredit)
   #      (defun my-paredit-nonlisp ()
   #        "Turn on paredit mode for non-lisps."
   #        (interactive)
   #        (set (make-local-variable 'paredit-space-for-delimiter-predicates)
   # 	    '((lambda (endp delimiter) nil)))
   #        (paredit-mode 1))

   #      ;; if you want to active paredit for a certain mode, add this 
   #      (add-hook 'js-mode-hook 'my-paredit-nonlisp)
   #    #+end_src
* Use org-mode to draw UML
#+begin_src emacs-lisp 
  (use-package plantuml-mode
    :ensure t
    :init
    :config
    (progn
      (add-to-list
       'org-src-lang-modes '("plantuml" . plantuml))
      (setq org-plantuml-jar-path
	    (expand-file-name "c:/Users/x1ezmr/notes/plantuml.jar"))
      ))
#+end_src

#+RESULTS:
: t
