* Auto-package-update
  #+BEGIN_SRC emacs-lisp
    (use-package auto-package-update
      :defer t
      :ensure t
      :config
      (progn
	;; pckages will be updated every 100 days
	;; the old ones will be removed
	(setq auto-package-update-delete-old-versions t
	      auto-package-update-interval 100)
	(auto-package-update-maybe)))
  #+END_SRC

  #+RESULTS:

* Interface tweaks
** alight commands
   #+BEGIN_SRC emacs-lisp
     (add-hook 'align-load-hook (lambda ()
                                  (add-to-list 'align-rules-list
                                               '(text-column-whitespace
                                                 (regexp  . "\\(^\\|\\S-\\)\\([ \t]+\\)")
                                                 (group   . 2)
                                                 (modes   . align-text-modes)
                                                 (repeat  . t)))))

   #+END_SRC

   #+RESULTS:
   | lambda | nil | (add-to-list (quote align-rules-list) (quote (text-column-whitespace (regexp . \(^\ | \S-\)\([ \n]+\)) (group . 2) (modes . align-text-modes) (repeat . t)))) |

** set font
   #+begin_src emacs-lisp
     ;; to adjust font dynamically
     ;; C-xC-+ and C-xC-- to increase or decrease the buffer text size
     (cond
      ((string-equal system-type "windows-nt")
       (set-default-font "Consolas 11")))
   #+end_src

   #+RESULTS:

** set global key-bindings
   Use "C-h k" to check the meaning of command for which the current key-binding belongs to in current mode.
   #+begin_src emacs-lisp
     ;; use cmd + n and cmd + p to select next and previous lines
     (global-set-key (kbd "s-n") (kbd "C-S-n"))
     (global-set-key (kbd "s-p") (kbd "C-S-p"))

     ;; use cmd + / to comment region of code
     (global-set-key (kbd "s-/") 'comment-region)
     ;; use cmd + \ to uncomment region of code
     (global-set-key (kbd "s-\\") 'uncomment-region)

     ;; use c-c c-c to execute a lisp function
     (global-set-key (kbd "C-c C-c") 'eval-last-sexp)

     ;; use f3 to use org-edit-special
     (global-set-key (kbd "<f3>") (kbd "C-c '"))
     ;; use f10 to format whole buffer
     (global-set-key (kbd "<f10>") (progn
                                     #'mark-whole-buffer
                                     #'indent-region))
     ;; use f5 to revert the buffer
     (global-set-key (kbd "<f5>") 'revert-buffer)
   #+end_src

   #+RESULTS:
   : 

** set buffer and shell
   #+begin_src emacs-lisp
     ;; no need for prompt for confirm when execute code block in org-mode
     (setq org-confirm-babel-evaluate nil)

     ;; make sure environment variables inside Emacs look the same as in the user's shell
     (use-package exec-path-from-shell
       :ensure t
       :config
       (progn
         (when (memq window-system '(mac ns x))
           (exec-path-from-shell-initialize))))
   #+end_src

   #+RESULTS:
   : t

** set line number
   #+BEGIN_SRC emacs-lisp
     (use-package nlinum
       :ensure t
       :config
       (progn
	 (global-nlinum-mode t)
	 ;; Preset `nlinum-format' for minimum width.
	 (defun my-nlinum-mode-hook ()
	   (when nlinum-mode
	     (setq-local nlinum-format
			 (concat "%" (number-to-string
				      ;; Guesstimate number of buffer lines.
				      (ceiling (log (max 1 (/ (buffer-size) 80)) 10)))
				 "d"))))
	 (add-hook 'nlinum-mode-hook #'my-nlinum-mode-hook)

	 ;; [[https://www.emacswiki.org/emacs/LineNumbers][solve bug with emacs daemon mode]]
	 (defun initialize-nlinum (&optional frame)
	   (require 'nlinum)
	   (add-hook 'prog-mode-hook 'nlinum-mode))
	 (when (daemonp)
	   (add-hook 'window-setup-hook 'initialize-nlinum)
	   (defadvice make-frame (around toggle-nlinum-mode compile activate)
	     (nlinum-mode -1) ad-do-it (nlinum-mode 1)))))
   #+END_SRC

   #+RESULTS:
   : t

** set adaptive-wrap
   #+BEGIN_SRC emacs-lisp
     (use-package adaptive-wrap
       :ensure t
       :config
       (progn
	 ;; (setq-default adaptive-wrap-extra-indent 2)
	 (add-hook 'visual-line-mode-hook #'adaptive-wrap-prefix-mode)
	 (global-visual-line-mode 1)))
   #+END_SRC

   #+RESULTS:
   : t

** change the cursor type and color
   #+begin_src emacs-lisp
     ;;(setq-default cursor-type '(hbar . 2))
     (setq-default cursor-type '(bar . 2))
   #+end_src

   #+RESULTS:
=(vbar . 1)
==(vbar . 2)
=** highlight current line
   #+begin_src emacs-lisp
     (global-hl-line-mode +1)
   #+end_src 

   #+RESULTS:
   : t

** use indent-guide
   #+begin_src emacs-lisp
     (use-package indent-guide
       :ensure t
       :config
       (progn
         (indent-guide-global-mode)))
   #+end_src 

   #+RESULTS:
   : t

** highlight-indentation
   #+BEGIN_SRC emacs-lisp
     (use-package highlight-indentation
       :ensure t
       :config
       (progn
         (setq highlight-indentation-blank-lines t)
         (add-hook 'yaml-mode-hook #'highlight-indentation-mode)))
   #+END_SRC

   #+RESULTS:
   : t

** which-key
   #+begin_src emacs-lisp
     (use-package which-key
       :defer 2
       :ensure t
       :config (which-key-mode))
   #+end_src

** try
   #+begin_src emacs-lisp
     (use-package try
       :defer 2
       :ensure t)
   #+end_src

* Swiper/Ivy/Counsel
  Swiper gives us a really efficient incremental search with regular expressions and Ivy / Counsel replace a lot of ido or helms completion functionality
  #+begin_src emacs-lisp
    ;; it looks like counsel is a requirement for swiper
    (use-package counsel
      :defer 1
      :ensure t
      :bind
      (("M-y" . counsel-yank-pop)
       :map ivy-minibuffer-map
       ("M-y" . ivy-next-line)))

    (use-package ivy
      :defer 1
      :ensure t
      :diminish (ivy-mode)
      :bind (("C-x b" . ivy-switch-buffer))
      :config
      (ivy-mode 1)
      (setq ivy-use-virtual-buffers t)
      (setq ivy-count-format "%d/%d ")
      (setq ivy-display-style 'fancy))


    (use-package swiper
      :defer 1
      :ensure try
      :bind (("C-s" . swiper)
	     ("C-r" . swiper)
	     ("C-c C-r" . ivy-resume)
	     ("M-x" . counsel-M-x)
	     ("C-x C-f" . counsel-find-file))
      :config
      (progn
	(ivy-mode 1)
	(setq ivy-use-virtual-buffers t)
	(setq ivy-display-style 'fancy)
	(define-key read-expression-map (kbd "C-r") 'counsel-expression-history)))
  #+end_src
  
* Keep parentheses balanced
** Paredit
   #+begin_src emacs-lisp
     (use-package paredit
       :defer 1
       :ensure t
       :init
       (progn
	 (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)
	 (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
	 (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
	 (add-hook 'ielm-mode-hook             #'enable-paredit-mode)
	 (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
	 (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
	 (add-hook 'scheme-mode-hook           #'enable-paredit-mode)
	 (add-hook 'racket-mode-hook           #'enable-paredit-mode)

	 ;; paredit with eldoc
	 (require 'eldoc) ; if not already loaded
	 (eldoc-add-command
	  'paredit-backward-delete
	  'paredit-close-round)

	 ;; paredit with slime repl
	 (add-hook 'slime-repl-mode-hook (lambda () (paredit-mode +1)))
	 ;; To alleviate the annoying habit of grabbing DEL in slime's REPL
	 ;; Stop SLIME's REPL from grabbing DEL,
	 ;; which is annoying when backspacing over a '('
	 (defun override-slime-repl-bindings-with-paredit ()
	   (define-key slime-repl-mode-map
	     (read-kbd-macro paredit-backward-delete-key) nil))
	 (add-hook 'slime-repl-mode-hook 'override-slime-repl-bindings-with-paredit)

	 ;; paredit with electric return
	 (defvar electrify-return-match
	   "[\]}\)\"]"
	   "If this regexp matches the text after the cursor, do an \"electric\"
       return.")
	 (defun electrify-return-if-match (arg)
	   "If the text after the cursor matches `electrify-return-match' then
       open and indent an empty line between the cursor and the text.  Move the
       cursor to the new line."
	   (interactive "P")
	   (let ((case-fold-search nil))
	     (if (looking-at electrify-return-match)
		 (save-excursion (newline-and-indent)))
	     (newline arg)
	     (indent-according-to-mode)))
	 ;; Using local-set-key in a mode-hook is a better idea.
	 (global-set-key (kbd "RET") 'electrify-return-if-match)))
   #+end_src
** complements to paredit
   #+begin_src emacs-lisp
     ;; Show matching arenthesis
     (show-paren-mode 1)
     (setq show-paren-delay 0)

     (require 'paren)
     (set-face-background 'show-paren-match (face-background 'default))
   #+end_src

   #+RESULTS:

** Autopair
   It is good to use it to add extra characters for pairing in some specific language mode. such as Python and JS. See [[https://github.com/joaotavora/autopair][autopair]].
   #+BEGIN_SRC emacs-lisp
     (use-package autopair
       :defer 2
       :ensure t
       :config
       (progn
         (defvar autopair-modes 
           '(js-mode python-mode scala-mode))
         (defun turn-on-autopair-mode () (autopair-mode 1))

         (dolist (mode autopair-modes) 
           (add-hook (intern (concat (symbol-name mode) "-hook")) 'turn-on-autopair-mode)
           (add-hook (intern (concat (symbol-name mode) "-hook")) (lambda ()
                                                                    (push '(?\( . ?\))
                                                                          (getf autopair-extra-pairs :code)))))

         (add-hook 'typescript-mode-hook 'turn-on-autopair-mode)
         (add-hook 'typescript-mode-hook (lambda ()
                                           (push '(?( . ?)) 
                                                 (getf autopair-extra-pairs :code))))

         ;; Autopair doesnâ€™t make much sense when paredit-mode is turned on, 
         ;; so it actually defers to paredit-mode when that is installed and enabled. 
         ;; Therefore, disable autopair when paredit is turned on
         (defadvice paredit-mode (around disable-autopairs-around (arg))
           ad-do-it
           (if (null ad-return-value)
               (autopair-mode 1)
             (autopair-mode 0)))
         (ad-activate 'paredit-mode)))
   #+END_SRC

   #+RESULTS:
   : t

** smartparens
   [[https://github.com/Fuco1/smartparens][smartparens]] is an excellent (newer) alternative to paredit. Many Clojure hackers have adopted it recently and you might want to give it a try as well.
   #+BEGIN_SRC emacs-lisp
     (use-package smartparens
       :ensure t
       :config
       (progn
         ;; Always start smartparens mode in js-mode
         (add-hook 'js-mode-hook #'smartparens-mode)))


        
   #+END_SRC
* Company
  #+BEGIN_SRC emacs-lisp
    (use-package company
      :defer t
      :ensure t
      :config
      (progn
	(setq completion-ignore-case t)
	(setq company-dabbrev-downcase 0)
	(setq company-idle-delay 0.01)
	(add-hook 'after-init-hook 'global-company-mode)))
  #+END_SRC

  #+RESULTS:
  : t

* Helm
  #+BEGIN_SRC emacs-lisp
    (use-package helm
      :ensure t
      :config
      (progn
        ;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
        ;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
        ;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.
        (global-set-key (kbd "C-c h") 'helm-command-prefix)
        (global-unset-key (kbd "C-x c"))

        (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
        (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB work in terminal
        (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

        (when (executable-find "curl")
          (setq helm-google-suggest-use-curl-p t))

        (setq helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
              helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
              helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
              helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
              helm-ff-file-name-history-use-recentf t
              helm-echo-input-in-header-line t)

        (defun spacemacs//helm-hide-minibuffer-maybe ()
          "Hide minibuffer in Helm session if we use the header line as input field."
          (when (with-helm-buffer helm-echo-input-in-header-line)
            (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
              (overlay-put ov 'window (selected-window))
              (overlay-put ov 'face
                           (let ((bg-color (face-background 'default nil)))
                             `(:background ,bg-color :foreground ,bg-color)))
              (setq-local cursor-type nil))))


        (add-hook 'helm-minibuffer-set-up-hook
                  'spacemacs//helm-hide-minibuffer-maybe)

        (setq helm-autoresize-max-height 0)
        (setq helm-autoresize-min-height 20)
        (helm-autoresize-mode 1)
        
        (helm-mode 1)))
  #+END_SRC

  #+RESULTS:
  : t

* Rainbow-delimiters
  #+BEGIN_SRC emacs-lisp
    (use-package rainbow-delimiters
      :ensure t
      :config
      (progn
        (add-hook 'lisp-mode-hook #'rainbow-delimiters-mode)
        (add-hook 'emacs-lisp-mode-hook #'rainbow-delimiters-mode)))
  #+END_SRC

  #+RESULTS:
  : t

* Aggressive-indent-mode
  #+BEGIN_SRC emacs-lisp
    (use-package aggressive-indent
      :ensure t
      :config
      (progn
        ;; active it for specific mode
        (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
        ;; deactive it for specific mode
        (add-to-list 'aggressive-indent-excluded-modes 'html-mode)))
  #+END_SRC

  #+RESULTS:
  : t

* Ace-window
  #+begin_src emacs-lisp
    (use-package ace-window
      :defer 2
      :ensure t
      :init
      :config
      (progn
	(setq aw-scope 'frame)
	(global-set-key (kbd "C-x O") 'other-frame)
	(global-set-key [remap other-window] 'ace-window)
	(custom-set-faces
	 '(aw-leading-char-face
	   ((t (:inherit ace-jump-face-foreground :height 3.0)))))))
  #+end_src

  #+RESULTS:
  : t
* Set emacs theme
  #+begin_src emacs-lisp
    ;; leuven-theme
    ;; gruvbox-theme
    (use-package material-theme
      :ensure t
      :config
      (progn
        (load-theme 'material t)
        ;; highlight matched parenthesis
        ;; (set-face-foreground 'show-paren-match "red")
        (set-face-attribute 'show-paren-match nil :weight 'extra-bold)))

  #+end_src

  #+RESULTS:
  : t

* Lisp programming configuration
** Eldoc to show argument list
   #+begin_src emacs-lisp
     (use-package eldoc
       :defer t
       :ensure t
       :init
       :config
       (progn
	 (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
	 (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
	 (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)
	 ;; highlight eldoc arguments in emacslisp
	 (defun eldoc-get-arg-index ()
	   (save-excursion
	     (let ((fn (eldoc-fnsym-in-current-sexp))
		   (i 0))
	       (unless (memq (char-syntax (char-before)) '(32 39)) ; ? , ?'
		 (condition-case err
		     (backward-sexp)             ;for safety
		   (error 1)))
	       (condition-case err
		   (while (not (equal fn (eldoc-current-symbol)))
		     (setq i (1+ i))
		     (backward-sexp))
		 (error 1))
	       (max 0 i))))

	 (defun eldoc-highlight-nth-arg (doc n)
	   (cond ((null doc) "")
		 ((<= n 0) doc)
		 (t
		  (let ((i 0))
		    (mapconcat
		     (lambda (arg)
		       (if (member arg '("&optional" "&rest"))
			   arg
			 (prog2
			     (if (= i n)
				 (put-text-property 0 (length arg) 'face 'underline arg))
			     arg
			   (setq i (1+ i)))))
		     (split-string doc) " ")))))

	 (defadvice eldoc-get-fnsym-args-string (around highlight activate)
	   ""
	   (setq ad-return-value (eldoc-highlight-nth-arg ad-do-it
							  (eldoc-get-arg-index))))))
   #+end_src

   #+RESULTS:
   : t

** Common-lisp
   #+begin_src emacs-lisp
     ;; slime for common-lisp 
     (use-package lisp-mode
       :config
       (progn
	 (use-package elisp-slime-nav
	   :ensure t
	   :commands elisp-slime-nav-mode)
	 (use-package macrostep
	   :ensure t
	   :bind ("C-c e" . macrostep-expand))
	 (use-package slime
	   :ensure t
	   :commands (slime slime-lisp-mode-hook)
	   :config
	   (progn
	     ;; make sbcl and slime accessible from command line
	     (if (string-equal system-type "windows-nt")
		 (progn
		   ;; Or, just edit path variable of system
		   ;; (add-to-list 'load-path "D:\\Program Files\\Lisp\\sbcl")
		   (add-to-list 'load-path "C:\\clisp-2.49")
		   (add-to-list 'load-path "D:\\Program Files\\slime")
		   (setf temporary-file-directory "c:/Users/x1ezmr/AppData/Local/Temp"))
	       (progn
		 (setq exec-path (append exec-path
					 '("/usr/local/bin")))))
	     ;; set 'sbcl' as lisp compiler
	     ;; (setq inferior-lisp-program "sbcl")
	     (setq inferior-lisp-program "clisp")
	     ;; (add-to-list 'slime-contribs 'slime-fancy)
	     ;; (slime-setup)
	     (require 'slime-autoloads)
	     (eval-after-load 'slime '(progn
					(slime-setup '(slime-fancy))))

	     (use-package slime-company
	       :ensure t
	       :config
	       (progn
		 (slime-setup '(slime-fancy slime-company))))))))


   #+end_src

   #+RESULTS:
   : t

** Racket
   #+begin_src emacs-lisp
     (use-package racket-mode
       :mode "\\.racket\\'"
       :ensure t
       :config
       (progn
	 (if (string-equal system-type "windows-nt")
	     (setq racket-program "c:/Program Files/Racket/Racket.exe")
	   (setq racket-program "/Applications/Racket_v7.0/bin/racket"))
	 (add-hook 'racket-mode-hook
		   (lambda ()
		     (define-key racket-mode-map (kbd "C-c r") 'racket-run)))
	 (setq tab-always-indent 'complete)
	 (add-hook 'racket-mode-hook      #'racket-unicode-input-method-enable)
	 (add-hook 'racket-repl-mode-hook #'racket-unicode-input-method-enable)

	 ;; setup file ending in ".scheme" to open in racket-mode 
	 (add-to-list 'auto-mode-alist '("\\.scheme\\'" . racket-mode))))
   #+end_src

   #+RESULTS:
   : t

* Scala programming
** ensime
   #+begin_src emacs-lisp
     (use-package ensime
       :mode "\\.scala\\'"
       :init 
       (if (string-equal system-type "windows-nt")
	   (progn
	     (setq exec-path (append exec-path '("c:/Program Files (x86)/scala/bin")))
	     (setq exec-path (append exec-path '("c:/Program Files (x86)/sbt/bin"))))
	 (setq exec-path (append exec-path '("/usr/local/bin"))))
       :ensure t
       :config
       (progn
	 ;; (add-hook 'scala-mode-hook 'ensime-scala-mode-hook)
	 (add-hook 'scala-mode-hook 'ensime-mode)))
   #+end_src

   #+RESULTS:
   : t

* Org mode enhancement
** key binding for org mode
   #+BEGIN_SRC emacs-lisp
     (add-hook 'org-mode-hook
	       (lambda () 
		 (progn
		   (local-set-key (kbd "<f9>") #'org-global-cycle)
		   (local-set-key (kbd "<f6>") #'org-toggle-inline-images))))
   #+END_SRC

   #+RESULTS:
   | (lambda nil (progn (local-set-key (kbd <f9>) (function org-global-cycle)) (local-set-key (kbd <f3>) (kbd C-c ')) (local-set-key (kbd <f6>) (function org-toggle-inline-images)))) | (lambda nil (local-set-key (kbd <f9>) (function org-global-cycle))) | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-show-block-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes |

** make code-block could be executed in org-mode
   #+begin_src emacs-lisp
     (cond
      ((string-equal system-type "darwin")
       (progn
         (org-babel-do-load-languages
          'org-babel-load-languages
          '((shell . t)
            (lisp . t)
            (C . t)))))
      ((string-equal system-type "gnu/linux")
       (progn
         (org-babel-do-load-languages
          'org-babel-load-languages
          '((sh . t)
            (C . t)))))
      ((string-equal system-type "windows-nt")
       (progn
         (org-babel-do-load-languages
          'org-babel-load-languages
          '((shell . t)
            (lisp . t)
            (C . t))))))
   #+end_src
   
   #+RESULTS:
** htmlize --- convert buffer text and decorations to HTML
   #+BEGIN_SRC emacs-lisp
     (use-package htmlize
       :defer 2
       :ensure t)
   #+END_SRC

   #+RESULTS:
   : t

* Treemacs
  #+begin_src emacs-lisp
    (use-package treemacs
      :defer t
      :ensure t
      :defer t
      :init
      (with-eval-after-load 'winum
        (define-key winum-keymap (kbd "M-0") #'treemacs-select-window))
      :config
      (progn
        ;; (pcase (cons (not (null (executable-find "git")))
        ;;              (not (null (executable-find "python3"))))
        ;;   (`(t . t)
        ;;    (treemacs-git-mode 'deferred))
        ;;   (`(t . _)
        ;;    (treemacs-git-mode 'simple)))
        (setq treemacs-collapse-dirs              (if (executable-find "python") 3 0)
              treemacs-file-event-delay           5000
              treemacs-follow-after-init          t
              treemacs-follow-recenter-distance   0.1
              treemacs-goto-tag-strategy          'refetch-index
              treemacs-indentation                1
              ;; indent guide
              treemacs-indentation-string (propertize " | " 'face 'font-lock-comment-face)
              ;; treemacs-indentation-string         "|"
              treemacs-is-never-other-window      nil
              treemacs-no-png-images              nil
              treemacs-project-follow-cleanup     nil
              treemacs-recenter-after-file-follow nil
              treemacs-recenter-after-tag-follow  nil
              treemacs-show-hidden-files          t
              treemacs-silent-filewatch           nil
              treemacs-silent-refresh             nil
              treemacs-sorting                    'alphabetic-desc
              treemacs-tag-follow-cleanup         t
              treemacs-tag-follow-delay           1.5
              treemacs-width                      40
              treemacs-follow-mode                t
              treemacs-filewatch-mode             t
              treemacs-git-mode nil))
      :bind
      (:map global-map
            ([f8]        . treemacs)
            ("M-0"       . treemacs-select-window)
            ("C-x t 1"   . treemacs-delete-other-windows)
            ("C-x t t"   . treemacs)
            ("C-x t B"   . treemacs-bookmark)
            ("C-x t C-t" . treemacs-find-file)
            ("C-x t M-t" . treemacs-find-tag)))

    (use-package treemacs-evil
      :defer t
      :after treemacs evil
      :ensure t)

    (use-package treemacs-projectile
      :defer t
      :after treemacs projectile
      :ensure t)

    (use-package treemacs-icons-dired
      :defer t
      :after treemacs dired
      :ensure t
      :config (treemacs-icons-dired-mode))


  #+end_src

  #+RESULTS:
* Yaml-mode
  #+begin_src emacs-lisp
    (use-package yaml-mode
      :mode "\\.yaml\\'"
      :ensure t
      :config
      (progn
	(add-hook 'yaml-mode-hook
		  (lambda ()
		    (define-key yaml-mode-map "\C-m" 'newline-and-indent)))))
  #+end_src

  #+RESULTS:
  : t

* Flycheck
  #+BEGIN_SRC emacs-lisp
    (use-package flycheck
      :defer 2
      :ensure t)

    (use-package flycheck-yamllint
      :defer t
      :ensure t
      :init
      (progn
	(eval-after-load 'flycheck
	  '(add-hook 'flycheck-mode-hook 'flycheck-yamllint-setup))))

  #+END_SRC

  #+RESULTS:
  | flycheck-yamllint-setup | flycheck-mode-set-explicitly |
* Typescript with Tide
  #+BEGIN_SRC emacs-lisp
    (use-package tide
      :ensure t
      :config
      (progn
	(defun setup-tide-mode ()
	  (interactive)
	  (tide-setup)
	  (flycheck-mode +1)
	  (setq flycheck-check-syntax-automatically '(save mode-enabled))
	  (eldoc-mode +1)
	  (tide-hl-identifier-mode +1)
	  (indent-guide-mode +1)
	  (auto-complete-mode +1))

	;; aligns annotation to the right hand side
	(setq company-tooltip-align-annotations t)

	;; formats the buffer before saving
	(add-hook 'before-save-hook 'tide-format-before-save)
	(add-hook 'typescript-mode-hook #'setup-tide-mode)))
  #+END_SRC

  #+RESULTS:
  : t

* Javascript
** setting up js2-mode
   #+BEGIN_SRC emacs-lisp
     (use-package js2-mode
       :ensure t
       :config
       (progn
	 (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
	 (add-hook 'js-mode-hook #'js2-imenu-extras-mode)

	 (use-package js2-refactor
	   :defer t
	   :ensure t
	   :config
	   (progn
	     (add-hook 'js2-mode-hook #'js2-refactor-mode)
	     (js2r-add-keybindings-with-prefix "C-c C-r")
	     (define-key js2-mode-map (kbd "C-k") #'js2r-kill)))

	 (use-package xref-js2
	   :defer t
	   :ensure t
	   :config
	   (progn
	     ;; js-mode (which js2 is based on) binds "M-." which conflicts with xref, so unbind it.
	     (define-key js-mode-map (kbd "M-.") nil)
	     (add-hook 'js2-mode-hook (lambda ()
					(add-hook 'xref-backend-functions #'xref-js2-xref-backend nil t)))))))
   #+END_SRC

   #+RESULTS:
   : t
   - Using js2-refactor
     - It is a javascript refactoring libary for emacs
     - see full list of keybindings [[https://github.com/magnars/js2-refactor.el][README]]
   - Using xref-js2
     - It supports for quickly jumping to function definitions or references to JavaScript projects in Emacs
     - Keybindings
       - M-. jump to definition
       - M-? jump to references
       - M-, Pop back to where M. was last invoked.

** setting up term and company-mode for auto-completion
   - Check simple usage at [[https://emacs.cafe/emacs/javascript/setup/2017/05/09/emacs-setup-javascript-2.html][setting up Emacs for JavaScript]]
   - You need to install tern on your localhost: npm install -g tern
   #+BEGIN_SRC emacs-lisp
     (use-package tern
       :mode "\\.js\\'"
       :ensure t
       :config
       (progn
	 (use-package company-tern
	   :defer t
	   :ensure t
	   :config
	   (progn
	     (add-to-list 'company-backend 'company-tern)
	     (add-hook 'js2-mode-hook (lambda ()
					(tern-mode)
					(company-mode)))
	     ;; Disable completion keybindings, as we use xref-js2 instead
	     (define-key tern-mode-keymap (kbd "M-.") nil)
	     (define-key tern-mode-keymap (kbd "M-,") nil)))))

   #+END_SRC

* Python development
** Packages you need to install through pip
   - rope
   - jedi
   - flake8
   - importmagic
** elpy
   - simple usage
     - show function signature, get docs: elpy-dock
     - code navigation, navigate code by treating them as hyperlinks:
       - elpy-goto-definition
       - pop-tag-mar
   #+BEGIN_SRC emacs-lisp
     (use-package elpy
       :ensure t
       :init
       (progn
         ;; (customize-variable (quote tab-stop-list))
         (add-to-list 'auto-mode-alist '("\\.py\\'" . python-mode))
         (setq elpy-rpc-backed "jedi")
         (elpy-enable))
       :config
       (progn
         (add-hook 'python-mode-hook 'elpy-mode)
         (with-eval-after-load 'elpy
           (setq python-shell-interpreter "ipython"
                 python-shell-interpreter-args "-i --simple-prompt")))
       :bind
       (("M-*" . pop-tag-mark)))
   #+END_SRC

   #+RESULTS:
   : pop-tag-mark

** indent-tools
   For indent python code and view python code
   #+BEGIN_SRC emacs-lisp
     (use-package indent-tools
       :ensure t
       :init
       (progn
         (setq tab-width 4)
         (add-to-list 'auto-mode-alist '("\\.py\\'" . python-mode))
         (add-hook 'python-mode-hook (lambda ()
                                       (define-key python-mode-map (kbd "C-c i") 'indent-tools-hydra/body)))))
   #+END_SRC

   #+RESULTS:

** Debugging
   Debugg using pdb
   #+BEGIN_SRC python
     # import ipd
     # ipdb.set_trace ()
   #+END_SRC

** Test Integration
   Configure your test Runner
   M-x elpy-set-test-runner
   C-c C-t  ;; runs test/ all tests

** Virtual Environment
   Elpy comes with pyvenv
   - M-x pyvenv-workon
   - M-x pyvenv-activate
   - M-x pyvenv-deactive

* Web mode
  - Auto opening, Auto completion, Auto expanders, code folding, Naviation
  - Configure to support snippets, such as HTML/Django
  - Context aware processing
  #+BEGIN_SRC emacs-lisp
    (use-package web-mode
      :mode "\\.html\\'"
      :ensure t
      :config
      (progn
	(add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
	(setq web-mode-engines-alist '(("django" . "\\.html\\'")))

	(setq web-mode-markup-indent-offset 2)
	(setq web-mode-code-indent-offset 2)
	(setq web-mode-css-indent-offset 2)

	(setq web-mode-enable-auto-pairing t)
	(setq web-mode-enable-auto-expanding t)
	(setq web-mode-enable-css-colorization t)))
  #+END_SRC

* JSON-mode
  Major mode for editing JSON files
  #+BEGIN_SRC emacs-lisp
    (use-package json-mode
      :mode "\\.json\\'"
      :ensure t)
  #+END_SRC

  #+RESULTS:

* Clojure programming
** CIDER
   It is the Clojure(Script) Interactive Development Environment.
   #+BEGIN_SRC emacs-lisp
     (use-package cider
       :ensure t
       :config
       (progn
         (add-hook 'cider-repl-mode-hook #'enable-paredit-mode)
         (add-hook 'cider-repl-mode-hook #'subword-mode)
         (add-hook 'cider-repl-mode-hook #'rainbow-delimiters-mode)
         (use-package helm-cider
           :ensure t
           :config
           (progn
             (add-hook 'cider-repl-mode-hook #'helm-cider-mode)))))
   #+END_SRC

   #+RESULTS:
   : t
   
** Clojure-mode
   #+BEGIN_SRC emacs-lisp
     (use-package clojure-mode
       :ensure t
       :config
       (progn
         (setq clojure-align-forms-automatically t)
         ;; make moving between characters faster
         (add-hook 'clojure-mode-hook #'subword-mode)
         ;; use paredit or smartparens 
         (add-hook 'clojure-mode-hook #'enable-paredit-mode)
         (add-hook 'clojure-mode-hook #'rainbow-delimiters-mode)
         (add-hook 'clojure-mode-hook #'aggressive-indent-mode)))

   #+END_SRC

   #+RESULTS:
   : t

   
** Userful key-bindings in Clojure programming
   - C-c C-d C-d will display documentation for the symbol under point, which can be a huge time-saver.
   - M-. will navigate to the source code for the symbol under point
   - M-, will return you to your original buffer and position
   - C-c C-d C-a lets you search for arbitrary text across function names and documentation
   - For paredit
     - M-( Surround expression after point in parentheses (paredit-wrap-round).
     - C-<left or right arrow>, surp or barf
     - C-M-f, C-M-b Move to the opening/closing parenthesis.
